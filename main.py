# Problem 29:
#     Distinct Powers
#
# Description:
#     Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
#         2^2 =  4,   2^3 =   8,   2^4 =  16,   2^5 =   32
#         3^2 =  9,   3^3 =  27,   3^4 =  81,   3^5 =  243
#         4^2 = 16,   4^3 =  64,   4^4 = 256,   4^5 = 1024
#         5^2 = 25,   5^3 = 125,   5^4 = 625,   5^5 = 3125
#
#     If they are then placed in numerical order, with any repeats removed,
#       we get the following sequence of 15 distinct terms:
#         4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
#
#     How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?

from math import floor, log, sqrt
import numpy as np


def main(n: int) -> int:
    """
    Returns the size of the set { a^b | 2 ≤ a ≤ `n`, 2 ≤ b ≤ `n` }

    Args:
        n (int): Natural number greater than 1

    Returns:
        Size of { a^b | 2 ≤ a ≤ `n`, 2 ≤ b ≤ `n` }

    Raises:
        AssertError: if incorrect args are given
    """
    assert type(n) == int and n > 1

    # Idea:
    #     First assume all possible combinations are distinct, giving count of (n-1)^2.
    #     Then exclude any other combinations which would duplicate lower ones.
    #
    #     Can't simply subtract 1 for any duplicated powers, as powers can be multi-duplicates.
    #     For example 16^2 is a duplicate of both 2^8 and 4^4, so don't want to double-subtract.
    #     Maintain bool matrix indicating whether power is to be counted.
    #
    #     Any duplicated powers, e.g. between 8^x and 16^y, have some least common base (2 in this case).
    #     Iterate across those possible least bases, and remove any double-counted powers among the full set
    #       of powers of the common base.
    #     For example, consider 2 and all its powers.
    #     Then look through the possible exponents and count only

    # Bool matrix to keep track of distinct powers
    # Assume everything distinct at first
    # Remember to shift indices by 2, as matrix corresponds to elements [2,n], in both dimensions
    is_distinct_power = np.reshape(np.repeat(1, (n-1)**2), (n-1, n-1))

    # Remove any duplicated powers
    x_checked = set()
    x_max = floor(sqrt(n))
    for x in range(2, x_max+1):
        if x in x_checked:
            continue
        else:
            # Collect all powers `a` of `x` within `n`
            #   -> a in { x^1, x^2, ..., x^p }
            p = floor(log(n)/log(x))
            x_powers = [x ** (i+1) for i in range(p)]

            # Highest power `x` is raised to is a^n = (x^p)^n = x^(p*n)
            xp_max = p * n

            # Check all powers of `x` in this range,
            #   and only count it once, if at all
            for xp in range(2, xp_max+1):
                found = False
                for i in range(1, p+1):
                    if xp % i == 0 and 2 <= xp // i <= n:
                        a = x_powers[i - 1]
                        b = xp // i
                        if not found and 2 <= b <= n:
                            found = True
                        else:
                            is_distinct_power[a-2][b-2] = False
                    else:
                        pass

            # Remember not to inspect further powers of `x` after this
            for a in x_powers:
                if a < x_max + 1:
                    x_checked.add(a)
                else:
                    break

    # Count all remaining distinct powers
    return int(np.sum(is_distinct_power))


if __name__ == '__main__':
    num = int(input('Enter a natural number greater than 1: '))
    distinct_powers = main(num)
    print('Number of distinct powers a^b:')
    print('  {}'.format(distinct_powers))
